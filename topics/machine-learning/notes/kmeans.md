# ğŸ” K-Means êµ°ì§‘í™” (Clustering) â€” ì›ë¦¬ & ì‹œê°í™”

ë¹„ì§€ë„ í•™ìŠµì—ì„œ **ë°ì´í„°ë¥¼ \(K\)ê°œì˜ êµ°ì§‘(cluster)** ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ëŒ€í‘œì  ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ê° êµ°ì§‘ì€ ë‚´ë¶€ì˜ ìƒ˜í”Œ ê°„ ê±°ë¦¬ê°€ ì‘ê³ , êµ°ì§‘ ê°„ ê±°ë¦¬ëŠ” í¬ê²Œ ìœ ì§€í•©ë‹ˆë‹¤.

---

## âš™ï¸ ì•Œê³ ë¦¬ì¦˜ ì›ë¦¬

1. **ì´ˆê¸°í™” (Initialization)**  
   - êµ°ì§‘ ìˆ˜ \(K\) ì§€ì •  
   - ì¤‘ì‹¬ì (centroid) \( \{\mu_1, \dots, \mu_K\}\) ì„ ë¬´ì‘ìœ„ ë˜ëŠ” K-Means++ ë°©ì‹ìœ¼ë¡œ ì„ íƒ  

2. **í• ë‹¹ ë‹¨ê³„ (Assignment Step)**  
   \[
   \text{for each } x_i:\quad
   c_i = \arg\min_{j\in\{1..K\}} \; \|x_i - \mu_j\|^2
   \]  
   â€“ ê° ìƒ˜í”Œì„ ê°€ì¥ ê°€ê¹Œìš´ ì¤‘ì‹¬ì ì— í• ë‹¹  

3. **ì—…ë°ì´íŠ¸ ë‹¨ê³„ (Update Step)**  
   \[
   \mu_j = \frac{1}{|C_j|}\sum_{x_i \in C_j} x_i
   \]  
   â€“ ê° êµ°ì§‘ \(C_j\) ì˜ í• ë‹¹ëœ ìƒ˜í”Œë“¤ì˜ í‰ê· ìœ¼ë¡œ ì¤‘ì‹¬ì  ì´ë™  

4. **ìˆ˜ë ´ íŒë‹¨ (Convergence Check)**  
   - ì¤‘ì‹¬ì  ì´ë™ ê±°ë¦¬ê°€ ê¸°ì¤€ ì´í•˜ì´ê±°ë‚˜  
   - ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜ ë„ë‹¬ ì‹œ ì¢…ë£Œ  

### ğŸ¯ ëª©ì  í•¨ìˆ˜ (Within-Cluster Sum of Squares)  
\[
J = \sum_{j=1}^K \sum_{x_i\in C_j} \|x_i - \mu_j\|^2
\]  
â€“ ê° êµ°ì§‘ ë‚´ ê±°ë¦¬ ì œê³±í•©ì„ ìµœì†Œí™”

---

## ğŸ“Š ì‹œê°í™” ê¸°ë²•

### 1ï¸âƒ£ ì—˜ë³´ìš° ë°©ë²• (Elbow Method)  
- \(K\)ë¥¼ ë‹¤ì–‘í•˜ê²Œ ì„¤ì •í•˜ê³  \(J(K)\) ê°’ì„ ê³„ì‚°  
- ê·¸ë˜í”„ì—ì„œ â€œíŒ”ê¿ˆì¹˜(Elbow)â€ ì§€ì ì´ ìµœì  \(K\) í›„ë³´  

```python
# ì˜ì‚¬ ì½”ë“œ ì˜ˆì‹œ
errors = []
for k in range(1,11):
    model = KMeans(n_clusters=k, random_state=0).fit(X)
    errors.append(model.inertia_)  # J(K)
plt.plot(range(1,11), errors, marker='o')
plt.xlabel('Number of Clusters K')
plt.ylabel('Inertia (Sum of Squared Distances)')
plt.show()
```

### 2ï¸âƒ£ êµ°ì§‘ í• ë‹¹ ê²°ê³¼ ì‹œê°í™”  
- **2D/3D ì‚°ì ë„**ì— ê° ìƒ˜í”Œì„ êµ°ì§‘ ìƒ‰ìƒë³„ë¡œ í‘œì‹œ  
- ì¤‘ì‹¬ì (\(\mu_j\)) ë§ˆì»¤ë¡œ ì˜¤ë²„ë ˆì´  

```python
# ì˜ì‚¬ ì½”ë“œ ì˜ˆì‹œ
labels = model.labels_
centroids = model.cluster_centers_
plt.scatter(X[:,0], X[:,1], c=labels, cmap='tab10')
plt.scatter(centroids[:,0], centroids[:,1], s=200, marker='X', edgecolor='k')
plt.show()
```

### 3ï¸âƒ£ ì‹¤ë£¨ì—£ ë¶„ì„ (Silhouette Analysis)  
- ê° ìƒ˜í”Œ \(i\) ì˜ ì‹¤ë£¨ì—£ ê³„ìˆ˜  
  \[
  s(i) = \frac{b(i) - a(i)}{\max\{a(i),\,b(i)\}}
  \]  
  - \(a(i)\): ê°™ì€ êµ°ì§‘ ë‚´ í‰ê·  ê±°ë¦¬  
  - \(b(i)\): ê°€ì¥ ê°€ê¹Œìš´ ë‹¤ë¥¸ êµ°ì§‘ê¹Œì§€ì˜ í‰ê·  ê±°ë¦¬  
- **ì „ì²´ í‰ê·  ì‹¤ë£¨ì—£**ì´ í´ìˆ˜ë¡ êµ°ì§‘í™” í’ˆì§ˆ ìš°ìˆ˜  

```python
from sklearn.metrics import silhouette_score
score = silhouette_score(X, labels)
print(f"Silhouette Score: {score:.3f}")
```

---

## ğŸ’¡ ì‹¤ë¬´ íŒ ìš”ì•½

1. **ìŠ¤ì¼€ì¼ë§**: ê±°ë¦¬ ê¸°ë°˜ ì•Œê³ ë¦¬ì¦˜ì´ë¯€ë¡œ `StandardScaler` ë“±ìœ¼ë¡œ í”¼ì²˜ í‘œì¤€í™”  
2. **K-Means++ ì´ˆê¸°í™”**: ì´ˆê¸° ì¤‘ì‹¬ì  ì„ íƒì„ ê°œì„ í•´ ìˆ˜ë ´ ì†ë„Â·ì•ˆì •ì„± â†‘  
3. **ë°˜ë³µ íšŸìˆ˜**: `max_iter`ë¥¼ ì¶©ë¶„íˆ í¬ê²Œ ì„¤ì •, `tol`ë¡œ ìˆ˜ë ´ ê¸°ì¤€ ì¡°ì •  
4. **ì¡ìŒ & ì´ìƒì¹˜**: ì´ìƒì¹˜ì— ë¯¼ê° â†’ ì‚¬ì „ ì œê±°í•˜ê±°ë‚˜ `MiniBatchKMeans` ê³ ë ¤  
5. **ì‹œê°í™”**: ì—˜ë³´ìš° + ì‹¤ë£¨ì—£ ë¶„ì„ìœ¼ë¡œ ìµœì  \(K\) ê²°ì •, ì‚°ì ë„ë¡œ êµ°ì§‘ êµ¬ì¡° ì§ê´€ì  í™•ì¸  
